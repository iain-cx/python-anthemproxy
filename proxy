#!/usr/bin/env python

import argparse
import asyncio
import ctypes
import json
import logging
import multiprocessing
import os
import struct

# Helper class to encode and decode protocol messages.
class AnthemProtocol(object):
  @classmethod
  def decode(self, b):
    if b is None:
      return None
    if not b:
      return ''
    if type(b) is str:
      return b.rstrip()
    return b.decode('utf-8').rstrip('\0').rstrip()

  @classmethod
  def encode(self, s):
    if type(s) is str and s:
      return s.encode('utf-8')
    return b''

# An Anthem device.
class AnthemDevice(object):
  LISTEN = '0.0.0.0'
  BROADCAST = '255.255.255.255'
  PORT = 14999
  VERSION = 1

  def __init__(self, *, host = None, port = None, proxy = None, alias = None, name = None, model = None, serial = None, version = None):
    self.alias = AnthemProtocol.decode(alias)
    self.name = AnthemProtocol.decode(name)
    self.host = host
    self.port = port or self.PORT
    self.version = version or self.VERSION
    self.serial = AnthemProtocol.decode(serial)
    if proxy is not None:
      self.proxy = proxy
      self.model = AnthemProxy.MODEL if proxy else AnthemProtocol.decode(model)
    else:
      self.model = AnthemProtocol.decode(model)
      self.proxy = AnthemProxy.check_model(self.model)

  @property
  def json(self):
    return json.dumps({
      'alias': self.alias if self.alias is not None else '',
      'host': self.host,
      'port': self.port,
      'name': self.name,
      'model': self.model,
      'serial': self.serial
    })

  @classmethod
  def from_json(self, s):
    try:
      data = json.loads(s)
      name = data.get('name')
      alias = data.get('alias') or name
      return AnthemDevice(host = data.get('host'), port = data.get('port'), alias = alias, name = name, model = data.get('model'), serial = data.get('serial'))
    except json.decoder.JSONDecodeError:
      raise Exception('Invalid JSON representation of AnthemDevice')

  @property
  def valid(self):
    return bool(self.host) and bool(self.port)

  @property
  def usable(self):
    try:
      return self.valid and len(self.name) and len(self.model) and len(self.serial)
    except TypeError:
      return False

# A discovery or response packet.
class AnthemDiscoveryPacket(object):
  MAGIC = 'PARC'
  FORMAT = '!4s2xbbLL16s16s16s'

  def __init__(self, *, discover = False, shutting_down = False, port = None, device = None):
    if device is None:
      device = AnthemDevice(proxy = True, port = port)
    elif type(device) is not AnthemDevice:
      raise Exception('AnthemDiscoveryPacket device parameter must be None or instance of AnthemDevice')

    self.discover = discover
    self.shutting_down = shutting_down
    self.device = device
    self.proxy = device.proxy if device is not None else False
    self.buffer = struct.pack(self.FORMAT, self.MAGIC.encode('utf-8'), 1 if self.discover else 0, 1 if self.shutting_down else 0, self.device.version, self.device.port, AnthemProtocol.encode(self.device.alias), AnthemProtocol.encode(self.device.model), AnthemProtocol.encode(self.device.serial))

  @classmethod
  def check_magic(self, magic):
    canon = magic.decode() if type(magic) is bytes else magic
    return canon == self.MAGIC

  @classmethod
  def receive(self, buffer, addr):
    host = None
    discover = None
    packet_type = 'Discovery'
    try:
      magic, discover, shutting_down, version, port, name, model, serial = struct.unpack(self.FORMAT, buffer)
      discover = bool(discover)
      if not discover:
        packet_type = 'Response'
      if addr is not None:
        host, port = addr
        logging.debug('%s packet received from %s:%u.', packet_type, host, port)
      else:
        logging.debug('%s packet received.', packet_type)
    except Exception as e:
      logging.error('Receiving discovery packet from %s:%u: %s', host, port, e)
      raise Exception('AnthemDiscoveryPacket.receive requires a valid packed buffer')

    if not AnthemDiscoveryPacket.check_magic(magic):
      logging.debug('Bad magic in discovery packet.')
      raise Exception('AnthemDiscoveryPacket.receive got bad magic')

    shutting_down = bool(shutting_down)
    device = AnthemDevice(host = host, port = port, name = name, model = model, serial = serial)
    if not discover and not device.usable:
      logging.error('Bad device in %s packet from %s:%u: %s', packet_type.lower(), host, port, buffer)
      raise Exception('AnthemDiscoveryPacket with invalid device')

    return AnthemDiscoveryPacket(discover = discover, shutting_down = shutting_down if not discover else False, port = port, device = device)

  def send(self, transport, addr):
    try:
      transport.sendto(self.buffer, addr)
    except Exception as e:
      logging.error('Sending %s: %s', self.buffer, e)

  @property
  def json(self):
    if self.device is None:
      return ''
    return json.dumps({
      'host': self.device.host,
      'port': self.device.port,
      'name': self.device.name,
      'model': self.device.model,
      'serial': self.device.serial
    })

# Connection from a client to the proxy.
class AnthemProxyClient(asyncio.Protocol):
  def __init__(self, proxy):
    self.proxy = proxy
    if self.proxy is None:
      raise Exception('AnthemProxyClient needs an AnthemProxy!')
    self.transport = None
    self.host = None
    self.port = None
    self.connected = True

  def connection_made(self, transport):
    self.transport = transport
    try:
      self.host, self.port = transport.get_extra_info('peername')
      logging.debug('New connection from %s:%u', self.host, self.port)
      self.proxy.client_connected(self)
    except:
      self.connected = False
      logging.error('Failed to accept new connection!')

  def connection_lost(self, e):
    self.connected = False
    if e is not None:
      logging.debug('Client %s:%u disconnected: %s', self.host, self.port, e)
    else:
      logging.debug('Client %s:%u disconnected.', self.host, self.port)
    self.proxy.client_disconnected(self)

  def data_received(self, data):
    logging.debug('Request from client %s:%u: %s', self.host, self.port, AnthemProtocol.decode(data))
    self.proxy.client_request(data)

  def write(self, data):
    if self.connected:
      logging.debug('Writing to client %s:%u: %s', self.host, self.port, AnthemProtocol.decode(data))
      self.transport.write(data)

# Connection from the proxy to the target.
class AnthemProxyConnection(asyncio.Protocol):
  def __init__(self, proxy = None):
    self.proxy = proxy
    if self.proxy is None:
      raise Exception('AnthemProxyConnection needs an AnthemProxy!')
    self.transport = None
    self.protocol = None
    self.connected = False
    self.reconnect()

  async def connect(self, data = None):
    if not self.transport or self.transport.is_closing():
      logging.info('Connecting to proxied device: %s', self.proxy.device.name)
      self.transport, self.protocol = await self.proxy.loop.create_connection(lambda: self, self.proxy.device.host, self.proxy.device.port)
      if not self.transport.is_closing():
        self.connected = True
        if data is not None:
          self.write(data)

  def reconnect(self, data = None):
    asyncio.ensure_future(self.connect(data))

  def close(self):
    if self.transport and not self.transport.is_closing():
      self.transport.close()
      self.transport = None
      self.connected = False

  def write(self, data):
    if self.connected:
      try:
        logging.debug('Writing to device %s: %s', self.proxy.device.name, AnthemProtocol.decode(data))
        self.transport.write(data)
        return
      except Exception as e:
        logging.error('Writing to device %s: %s', self.proxy.device.name, e)
    self.reconnect(data)

  def connection_made(self, transport):
    host, port = transport.get_extra_info('peername')
    logging.debug('Connected to proxied device %s at %s:%u', self.proxy.device.name, host, port)

  def connection_lost(self, e):
    if e is not None:
      logging.debug('Disconnected from proxied device %s: %s', self.proxy.device.name, e)
    else:
      logging.debug('Disconnected from proxied device %s.', self.proxy.device.name)
    self.transport = None
    self.protocol = None
    self.connected = False
    if self.proxy.listen:
      self.reconnect()

  def data_received(self, data):
    logging.debug('Message from device: %s', AnthemProtocol.decode(data))
    self.proxy.proxy_response(data)

# A proxy for an AnthemDevice.
class AnthemProxy(asyncio.Protocol):
  MODEL = 'Anthem Proxy'

  def __init__(self, device, host = None, port = None, forward = None):
    self.loop = asyncio.get_running_loop()
    self.clients = set()
    self.connection = None
    self.device = device
    self.host = host or AnthemDevice.LISTEN
    self.port = port or AnthemDevice.PORT
    self.transport = None
    self.protocol = None
    self.discovery = None
    self.listen = True
    self.forward = forward or False
    self.server = None

  @classmethod
  def check_model(self, model):
    canon = AnthemProtocol.decode(model)
    return canon == self.MODEL

  async def run(self):
    self.transport, self.protocol = await self.loop.create_datagram_endpoint(lambda: self, local_addr = (self.host, self.port), reuse_port = True, allow_broadcast = True)
    try:
      self.connection = AnthemProxyConnection(self)
      self.server = await self.loop.create_server(lambda: AnthemProxyClient(self), self.host, self.port, reuse_port = True, start_serving = False)
      while self.listen:
        await self.server.start_serving()
    finally:
      if not self.transport.is_closing():
        self.transport.close()

  def client_connected(self, client):
    logging.debug('Adding client %s:%u.', client.host, client.port)
    self.clients.add(client)

  def client_disconnected(self, client):
    logging.debug('Removing disconnected client %s:%u.', client.host, client.port)
    self.clients.remove(client)

  def connection_made(self, transport):
    logging.debug('Discovery transport ready for proxy: %s', self.device.alias)
    self.discovery = transport

  def connection_lost(self, e):
    logging.info('Shutting down.')
    self.listen = False
    self.connection.close()

  def on_discovery_request(self, host, port):
    addr = (host, port)
    if not self.device.name or not self.device.host:
      logging.debug("Can't respond yet.")
      return
    packet = AnthemDiscoveryPacket(device = self.device)
    try:
      logging.debug('Responding to %s:%u', host, port)
      packet.send(self.discovery, addr)
    except Exception as e:
      logging.error('Sending discovery packet to %s:%u: %s', host, port, e)
      self.discovery.close()

  def on_discovery_reply(self, host, port, version, name, model, serial):
    if self.device.host and host != self.device.host:
      logging.debug('Ignoring reply from %s not %s.', host, self.device.host)
      return
    if self.device.port and port != self.device.port:
      logging.debug('Ignoring reply from port %s not %s.', port, self.device.port)
      return
    self.device.host = host
    self.device.port = port
    logging.debug('Device: %s; model: %s; serial: %s', AnthemProtocol.decode(name), AnthemProtocol.decode(model), AnthemProtocol.decode(serial))
    if not self.device.name:
      self.device.name = AnthemProtocol.decode(name)
      if len(self.device.name) < 10:
        self.device.name += ' proxy'
      elif len(self.device.name) < 16:
        self.device.name += '*'
    self.device.version = version
    self.device.model = AnthemProtocol.decode(model)
    self.device.serial = AnthemProtocol.decode(serial)

  def datagram_received(self, data, addr):
    packet = None
    try:
      packet = AnthemDiscoveryPacket.receive(data, addr)
    except:
      return
    host, port = addr
    if packet.discover:
      if packet.proxy and not self.forward:
        logging.debug('Ignoring proxy discovery packet')
        return
      return self.on_discovery_request(host, port)
    else:
      return self.on_discovery_reply(host, port, packet.device.version, packet.device.name, packet.device.model, packet.device.serial)

  def client_request(self, data):
    if not self.device.host or not self.device.port:
      logging.debug("Can't reply without proxy")
      return

    self.connection.write(data)

  def proxy_response(self, data):
    for client in self.clients:
      client.write(data)

# A discovery client.
class AnthemDiscovery(asyncio.Protocol):
  CONTINUE = True
  STOP = False

  def __init__(self, *, host = None, port = None, broadcast = None, on_receive = None, forward = None):
    self.host = host or AnthemDevice.LISTEN
    self.port = port or AnthemDevice.PORT
    self.broadcast = broadcast or AnthemDevice.BROADCAST
    self.packet = AnthemDiscoveryPacket(discover = True)
    self.on_receive = on_receive if on_receive is not None else lambda packet: False
    self.transport = None
    self.protocol = None
    self.listen = True
    self.forward = forward or False
    self.server = None

  async def run(self):
    loop = asyncio.get_running_loop()
    self.transport, self.protocol = await loop.create_datagram_endpoint(lambda: self, local_addr = (self.host, self.port), reuse_port = True, allow_broadcast = True)

    logging.debug('Sending discovery packets to %s:%u.', self.broadcast, AnthemDevice.PORT)
    logging.debug('Listening for responses to %s:%u.', self.host, self.port)
    try:
      while self.listen:
        self.transport.sendto(self.packet.buffer, (self.broadcast, AnthemDevice.PORT))
        await asyncio.sleep(0.5)
    finally:
      self.transport.close()

  def datagram_received(self, data, addr):
    packet = None
    try:
      packet = AnthemDiscoveryPacket.receive(data, addr)
    except:
      return

    if not packet:
      return
    if packet.discover:
      return
    if not packet.device:
      return
    if self.on_receive(packet) == self.STOP:
      self.listen = False

async def discover(bind, port, broadcast, forward = False):
  seen = {}

  def show_device(packet):
    output = packet.json
    if not seen.get(output):
      print(output)
    seen[output] = True
    return AnthemDiscovery.CONTINUE

  discovery = AnthemDiscovery(host = bind, port = port, broadcast = broadcast, on_receive = show_device, forward = forward)
  return await discovery.run()

async def proxy(bind, listen, host, port, alias, name, model, serial, forward = False):
  def query_device(packet):
    if packet.discover:
      return AnthemDiscovery.CONTINUE
    serialised.value = packet.device.json
    return AnthemDiscovery.STOP

  target_host = multiprocessing.Value(ctypes.c_wchar_p, '')
  target_port = multiprocessing.Value('i', 0)

  target = AnthemDevice(host = host, port = port, alias = alias, name = name, model = model, serial = serial)
  announced = False
  while not target.name or not target.usable:
    if target.valid:
      target_host.value = target.host
      target_port.value = target.port
    serialised = multiprocessing.Value(ctypes.c_wchar_p, '')
    if not announced:
      logging.info('Discovering target device details.')
      announced = True
    discovery = AnthemDiscovery(host = bind, port = listen, broadcast = host, on_receive = query_device, forward = forward)
    await discovery.run()

    canon = AnthemDevice.from_json(serialised.value)
    if not target.host or target.host != canon.host:
      target.host = canon.host
      target.port = canon.port
      logging.debug('Discovered host: %s', target.host)
    if not target.name:
      target.name = canon.name
      logging.debug('Discovered name: %s', target.name)
    if not target.model:
      target.model = canon.model
      logging.debug('Discovered model: %s', target.model)
    if not target.serial:
      target.serial = canon.serial
      logging.debug('Discovered serial: %s', target.serial)

  logging.info('Proxying: %s', target.json)
  proxy = AnthemProxy(target, bind, listen, forward = forward)
  return await proxy.run()

async def main(args):
  host = args.bind
  port = args.listen
  action = args.action[0]
  if action == 'discover':
    return await discover(bind = args.bind, port = port, broadcast = args.host, forward = args.forward)
  elif action == 'proxy':
    return await proxy(bind = args.bind, listen = args.listen, host = args.host, port = args.port, alias = args.alias, name = args.name, model = args.model, serial = args.serial, forward = args.forward)

def env_or_arg(parser, *args, **kwargs):
  canon = { k: v for k, v in kwargs.items() }
  for arg in args:
    if arg.startswith('--'):
      key = '_'.join(['ANTHEMPROXY', arg[2:].upper()])
      value = os.environ.get(key, kwargs.get('default'))
      coerce = kwargs.get('type', str)
      if coerce is bool:
        del(canon['type'])
      if value is not None:
        try:
          canon['default'] = coerce(value)
        except:
          pass
  parser.add_argument(*args, **canon)

parser = argparse.ArgumentParser('anthem_proxy')
env_or_arg(parser, '-a', '--alias', help = 'Proxy name')
env_or_arg(parser, '-b', '--bind', default = AnthemDevice.LISTEN, help = 'Bind address')
env_or_arg(parser, '-d', '--debug', type = bool, action = 'store_true', help = 'Debug mode')
env_or_arg(parser, '-f', '--forward', type = bool, action = 'store_true', help = 'Accept requests from other proxies')
env_or_arg(parser, '-l', '--listen', type = int, default = AnthemDevice.PORT, help = 'Bind port')
env_or_arg(parser, '-m', '--model', help = 'Device model')
env_or_arg(parser, '-n', '--name', help = 'Device name')
env_or_arg(parser, '-p', '--port', type = int, default = AnthemDevice.PORT, help = 'Device port')
env_or_arg(parser, '-s', '--serial', help = 'Device serial number')
env_or_arg(parser, '-t', '--host', help = 'Target device IP or hostname')
parser.add_argument('action', choices = ['discover', 'proxy'], nargs = 1)
args = parser.parse_args()

logging.basicConfig(level = logging.DEBUG if args.debug or os.getenv('DEBUG') else logging.INFO, format = r'%(asctime)s %(module)s.%(funcName)s:%(lineno)d %(levelname)s: %(message)s', datefmt = r'%Y-%m-%dT%H:%M:%SZ')

try:
  asyncio.run(main(args))
except KeyboardInterrupt:
  # XXX
  pass
except:
  raise
