#!/usr/bin/env python

import argparse
import asyncio
import ctypes
import json
import multiprocessing
import struct

def btos(b):
  if not b:
    return ''
  if type(b) is str:
    return b
  return b.decode().rstrip('\0')

class AnthemDevice(object):
  MODEL = 'Anthem Proxy'
  PORT = 14999

  def __init__(self, *, host = None, port = None, proxy = None, name = None, model = None, serial = None):
    self.name = btos(name)
    self.host = host
    self.port = port or self.PORT
    self.serial = btos(serial)
    if proxy is not None:
      self.proxy = proxy
      self.model = self.MODEL if proxy else btos(model)
    else:
      self.model = btos(model)
      self.proxy = model == self.MODEL

  @property
  def json(self):
    return json.dumps({
      'host': self.host,
      'port': self.port,
      'name': self.name,
      'model': self.model,
      'serial': self.serial
    })

  @classmethod
  def from_json(self, s):
    try:
      data = json.loads(s)
      return AnthemDevice(host = data['host'], port = data['port'], name = data['name'], model = data['model'], serial = data['serial'])
    except json.decoder.JSONDecodeError:
      raise Exception('Invalid JSON representation of AnthemDevice')

  @property
  def valid(self):
    return bool(self.host) and bool(self.port)

  @property
  def usable(self):
    return self.valid and len(self.name) and len(self.model) and len(self.serial)

  @property
  def bytes_name(self):
    return self.name.encode('utf-8') if self.name else b''

  @property
  def bytes_model(self):
    return self.model.encode('utf-8') if self.model else b''

  @property
  def bytes_serial(self):
    return self.serial.encode('utf-8') if self.serial else b''

class AnthemDiscoveryPacket(object):
  MAGIC = 'PARC'
  VERSION = 1
  FORMAT = '!4s2xbbLL16s16s16s'

  def __init__(self, *, discover = False, shutting_down = False, version = None, port = None, device = None):
    if device is None:
      device = AnthemDevice(proxy = True, port = port)
    elif type(device) is not AnthemDevice:
      raise Exception('AnthemDiscoveryPacket device parameter must be None or instance of AnthemDevice')

    self.discover = discover
    self.shutting_down = shutting_down
    self.version = version if version is not None else self.VERSION
    self.device = device
    self.proxy = device.proxy if device is not None else False
    self.buffer = struct.pack(self.FORMAT, self.MAGIC.encode('utf-8'), 1 if self.discover else 0, 1 if self.shutting_down else 0, self.version, self.device.port, self.device.bytes_name, self.device.bytes_model, self.device.bytes_serial)

  @classmethod
  def receive(self, buffer, addr):
    try:
      magic, discover, shutting_down, version, port, name, model, serial = struct.unpack(self.FORMAT, buffer)
    except Exception as e:
      print(f'oops: {str(e)}')
      raise Exception('AnthemDiscoveryPacket.receive requires a valid packed buffer')

    discover = bool(discover)
    shutting_down = bool(shutting_down)
    host = addr[0] if addr is not None else None
    device = AnthemDevice(host = host, port = port, name = name, model = model, serial = serial)
    if not discover and not device.usable:
      print(f'bad device {buffer}; discover: {discover}')
      raise Exception('AnthemDiscoveryPacket with invalid device')

    return AnthemDiscoveryPacket(discover = discover, shutting_down = shutting_down if not discover else False, version = version, port = port, device = device)

  @property
  def json(self):
    if self.device is None:
      return ''
    return json.dumps({
      'host': self.device.host,
      'port': self.device.port,
      'name': self.device.name,
      'model': self.device.model,
      'serial': self.device.serial
    })

class AnthemProxy(asyncio.Protocol):
  MAGIC = 'PARC'
  PROXY_MAGIC = 'Anthem Proxy'

  def __init__(self, host = None, port = None, device = None, model = None, serial = None):
    print('__init__')
    self.udp = None
    self.tcp = None
    self.proxied_host = host
    self.proxied_port = port
    self.proxied_version = 1
    self.proxied_device = device
    self.proxied_model = model
    self.proxied_serial = serial

  def connection_made(self, transport):
    print('connection_made')
    if type(transport) is asyncio.selector_events._SelectorDatagramTransport: # XXX
      self.udp = transport
    else:
      self.tcp = transport

  def connection_lost(self, e):
    print('connection_lost')

  async def query(self):
    addr = ('255.255.255.255', AnthemDevice.PORT)
    return self.send_discovery_packet(addr, announce = True, device = self.PROXY_MAGIC)

  def send_discovery_packet(self, addr = None, announce = False, version = 0, port = None, device = None, model = None, serial = None):
    if device is None:
      device = ''
    if model is None:
      model = ''
    if serial is None:
      serial = ''
    buffer = struct.pack('!4s2xbbLL16s16s16s', self.MAGIC.encode(), 1 if announce else 0, 0, version, port or AnthemDevice.PORT, device.encode(), model.encode(), serial.encode())
    print(f'Sending packet: {buffer} to {addr}')
    return self.udp.sendto(buffer, addr)

  def on_discovery_request(self, addr):
    host, port = addr
    print(f'Discovery request from {host}')
    if not self.proxied_device or not self.proxied_host:
      print("Can't respond yet")
      return
    return self.send_discovery_packet(addr, version = self.proxied_version, device = self.proxied_device, model = self.proxied_model, serial = self.proxied_serial)

  def on_discovery_reply(self, host, port, version, device, model, serial):
    if self.proxied_host and host != self.proxied_host:
      print(f'Ignoring reply from {host} not {self.proxied_host}')
      return
    if self.proxied_port and port != self.proxied_port:
      print(f'Ignoring reply from port {port} not {self.proxied_port}')
      return
    self.proxied_host = host
    self.proxied_port = port
    print(f'Device: {device.decode()}; model: {model.decode()}; serial: {serial.decode()}')
    proxied_device = btos(device)
    if len(proxied_device) < 10:
      proxied_device += ' proxy'
    elif len(proxied_device) < 16:
      proxied_device += '*'
    self.proxied_version = version
    self.proxied_device = proxied_device
    self.proxied_model = btos(model)
    self.proxied_serial = btos(serial)

  def datagram_received(self, data, addr):
    host, port = addr
    decoded = struct.unpack('!4s2xbbLL16s16s16s', data)
    print(f'datagram_received: {decoded} from {addr}')
    magic, announce, powering_off, version, port, device, model, serial = decoded
    if magic.decode() != self.MAGIC:
      return
    if announce:
      if device == struct.pack('!16s', self.PROXY_MAGIC.encode()):
        print('Ignoring proxy discovery packet')
        return
      return self.on_discovery_request(addr)
    else:
      return self.on_discovery_reply(host, port, version, device, model, serial)

  def data_received(self, data):
    print(f'data_received: {data} from {self.tcp.get_extra_info("peername")}')
    if not self.proxied_host or not self.proxied_port:
      print("Can't reply without proxy")
      return
    proxied_addr = (self.proxied_host, self.proxied_port)

    # XXX wrap
    class Hack(asyncio.Protocol):
      def __init__(self, proxy_transport, data):
        self.proxy_transport = proxy_transport
        self.request = data
        self.response = None

      def connection_made(self, transport):
        transport.write(self.request)

      def data_received(self, data):
        print(f'proxy response: {data.decode()}')
        self.response = data
        self.proxy_transport.write(data)
        #self.proxy_transport.close()

    async def doit(proxy, data):
      loop = asyncio.get_running_loop()
      hack = Hack(proxy.tcp, data)
      transport, protocol = await loop.create_connection(lambda: hack, proxy.proxied_host, proxy.proxied_port)
      deadline = 3
      try:
        while deadline > 0:
          if hack.response:
            break
          await asyncio.sleep(1)
          deadline -= 1
      finally:
        transport.close()

    asyncio.ensure_future(doit(self, data))

class AnthemDiscovery(asyncio.Protocol):
  CONTINUE = True
  STOP = False

  def __init__(self, *, host = None, port = None, on_receive = None):
    self.host = host or '0.0.0.0'
    self.port = port or AnthemDevice.PORT
    self.packet = AnthemDiscoveryPacket(discover = True)
    self.on_receive = on_receive if on_receive is not None else lambda packet: False
    self.listen = True

  async def run(self):
    loop = asyncio.get_running_loop()
    self.transport, self.discovery = await loop.create_datagram_endpoint(lambda: self, local_addr = (self.host, self.port), reuse_port = True, allow_broadcast = True)

    try:
      while self.listen:
        self.transport.sendto(self.packet.buffer, ('255.255.255.255', AnthemDevice.PORT))
        await asyncio.sleep(0.5)
    finally:
      self.transport.close()

  def datagram_received(self, data, addr):
    packet = None
    try:
      packet = AnthemDiscoveryPacket.receive(data, addr)
    except:
      return

    if not packet:
      return
    if packet.discover:
      return
    if not packet.device:
      return
    if self.on_receive(packet) == self.STOP:
      self.listen = False

async def discover(host, port):
  def show_device(packet):
    output = packet.json
    if not seen.get(output):
      print(output)
    seen[output] = True
    return AnthemDiscovery.CONTINUE

  seen = {}
  protocol = AnthemDiscovery(host = host, port = port, on_receive = show_device)
  return await protocol.run()

async def proxy(host, port, target):
  def query_device(packet):
    if packet.discover:
      return AnthemDiscovery.CONTINUE
    if target_host.value:
      if packet.device.host != target_host.value:
        print(f'wrong host: {packet.device.host} not {target_host.value}')
        return AnthemDiscovery.CONTINUE
      if packet.device.port != target_port.value:
        print(f'wrong port: {packet.device.port} not {target_port.value}')
        return AnthemDiscovery.CONTINUE
    serialised.value = packet.device.json
    return AnthemDiscovery.STOP

  target_host = multiprocessing.Value(ctypes.c_wchar_p, '')
  target_port = multiprocessing.Value('i', 0)
  while not target.usable:
    if target.valid:
      target_host.value = target.host
      target_port.value = target.port
    serialised = multiprocessing.Value(ctypes.c_wchar_p, '')
    protocol = AnthemDiscovery(host = host, port = port, on_receive = query_device)
    await protocol.run()

    canon = AnthemDevice.from_json(serialised.value)
    if not target.host:
      target.host = canon.host
      target.port = canon.port
      print(f'discovered host: {target.host}')
    if not target.name:
      target.name = canon.name
      print(f'discovered name: {target.name}')
    if not target.model:
      target.model = canon.model
      print(f'discovered model: {target.model}')
    if not target.serial:
      target.serial = canon.serial
      print(f'discovered serial: {target.serial}')

  print(f'Proxying: {target.json}')
  # XXX
  loop = asyncio.get_running_loop()
  proxy = AnthemProxy(host, port, device = target.name, model = target.model, serial = target.serial)

  transport, discovery = await loop.create_datagram_endpoint(lambda: proxy, local_addr = (host, port), reuse_port = True, allow_broadcast = True)
  server = await loop.create_server(lambda: proxy, host, port, reuse_port = True)

  try:
    await server.serve_forever()
  finally:
    transport.close()

async def main(args):
  host = args.bind
  port = args.listen
  action = args.action[0]
  if action == 'discover':
    return await discover(host = host, port = port)
  elif action == 'proxy':
    target = AnthemDevice(host = args.host, port = args.port, name = args.name, model = args.model, serial = args.serial)
    return await proxy(host, port, target)

parser = argparse.ArgumentParser('anthem_proxy')
parser.add_argument('-a', '--name', help = 'Proxy name')
parser.add_argument('-b', '--bind', default = '0.0.0.0', help = 'Bind address')
parser.add_argument('-d', '--debug', action = 'store_true', help = 'Debug mode')
parser.add_argument('-l', '--listen', type = int, default = AnthemDevice.PORT, help = 'Bind port')
parser.add_argument('-m', '--model', help = 'Device model')
parser.add_argument('-p', '--port', type = int, default = AnthemDevice.PORT, help = 'Device port')
parser.add_argument('-s', '--serial', help = 'Device serial number')
parser.add_argument('-t', '--host', help = 'Target device IP or hostname')
parser.add_argument('action', choices = ['discover', 'proxy'], nargs = 1)
args = parser.parse_args()

asyncio.run(main(args))
